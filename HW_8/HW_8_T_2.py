# 2. Доработать алгоритм Дейкстры (рассматривался на уроке), чтобы он дополнительно возвращал список вершин,
# которые необходимо обойти.

g = [
    [0, 0, 1, 1, 9, 0, 0, 0],
    [0, 0, 9, 4, 0, 0, 7, 0],
    [0, 9, 0, 0, 3, 0, 6, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 7, 0, 8, 1, 0, 0],
    [0, 0, 0, 0, 0, 1, 2, 0],
]

def dijkstra(graph, start):
    lenght = len(graph) # Длина графа (количество вершин)
    is_visited = [False] * lenght # Посещение вершины (да/нет). По умолчанию - все вершины не посещены
    cost = [float('inf')] * lenght # Стоимость пути до вершины. По умолчанию - бесконечность
    parent = [-1] * lenght # Родитель для вершины
    visited = []
    cost[start] = min_cost = 0 # Стоимость пути до стартовой вершины и Минимальная стоимость пути до вершины

    def sort_array(array): # Добавим функцию для сортировки пузырьком списка посещенных вершин
        for i in range(len(array)):
            for j in range(0, len(array) - i - 1):
                if array[j] > array[j + 1]:
                    array[j], array[j + 1] = array[j + 1], array[j]

    while min_cost < float('inf'): # Пока минимальная стоимость меньше бесконечности - обходим наш граф:

        is_visited[start] = True # Отмечаем вершину, которая в данный момент стартовая, как посещенную

        for i, vertex in enumerate(graph[start]):   # Обходим строку графа, в которой хранится значение старт
            if vertex != 0 and not is_visited[i]:   # Если значение вершины не равно 0 (есть ребро) \
                                                    # и эта вершина еще не посещена:

                if cost[i] > vertex + cost[start]:  # Если растояние до i-ой вершины больше суммы расстояний\
                                                    # от вершины старта до вершины i плюс значени которое уже\
                                                    # хранится в вершине старта:
                    cost[i] = vertex + cost[start]  # производим замену! Для i-ой вершины записываем более короткое\
                                                    # расстояние
                    parent[i] = start               # указываем какая вершины является родительской

        min_cost = float('inf') # Изменяем значение минимального пути на бесконечность
        for i in range(lenght): # Проходим по всем вершинам графа
            if min_cost > cost[i] and not is_visited[i]:    # Если минимальная стоимость больше, чем стоимость пути\
                                                            # до очередной вершины, и при этом эту вершину еше\
                                                            # не посещали:
                min_cost = cost[i]  # То изменяем значение минимальной стоимости
                start = i # Делаем текущую вершину - стартовой
                if i not in visited: # Если в списке посещенных вершин еще нет текущец вершины:
                    visited.append(i) # Добавляем ее в список

    sort_array(visited) # Отсортируем наш список посещенных вершин, чтобы вывод был красивее
    return f'Стоимость путей до вершин: {cost}, посещенные вершины: {visited}'

s = int(input('От какой вершины идем: '))
print(dijkstra(g, s))
